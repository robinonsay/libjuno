/*
    MIT License

    Copyright (c) 2025 Robin A. Onsay

    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.
*/

/**
    This API has been generated by LibJuno:
    https://www.robinonsay.com/libjuno/
*/

/**
    This header contains the juno_ds library API
    @author Robin Onsay
*/
#ifndef JUNO_DS_API_H
#define JUNO_DS_API_H
#include "juno/ds/array_api.h"
#include "juno/macros.h"
#include "juno/memory/pointer_api.h"
#include "juno/status.h"
#include "juno/module.h"
#include <stdbool.h>
#include <stddef.h>
#ifdef __cplusplus
extern "C"
{
#endif

typedef struct JUNO_DS_HEAP_ROOT_TAG JUNO_DS_HEAP_ROOT_T;   /**< Opaque root that stores heap metadata and API pointer. */
typedef struct JUNO_DS_HEAP_API_TAG  JUNO_DS_HEAP_API_T;    /**< API vtable you implement for your storage and element type. */

/**
 * @brief Result type carrying an index on success.
 * tStatus conveys success/error; tOk holds the index.
 */
JUNO_MODULE_RESULT(JUNO_DS_HEAP_INDEX_RESULT_T, size_t);

/**
 * @brief Option type for an index. bIsSome indicates presence; tSome is the index.
 */
JUNO_MODULE_OPTION(JUNO_DS_HEAP_INDEX_OPTION_T, size_t);

/**
 * @brief Result that wraps an optional index.
 */
JUNO_MODULE_RESULT(JUNO_DS_HEAP_INDEX_OPTION_RESULT_T, JUNO_DS_HEAP_INDEX_OPTION_T);

/**
 * @brief Result of a comparison: tOk=true means the heap property holds
 * between the given parent and child indices; false means it does not.
 */
JUNO_MODULE_RESULT(JUNO_DS_HEAP_COMPARE_RESULT_T, bool);


struct JUNO_DS_HEAP_ROOT_TAG JUNO_MODULE_DERIVE_WITH_API(JUNO_DS_ARRAY_ROOT_T, JUNO_DS_HEAP_API_T,
    size_t zLength;     /**< Current number of elements in the heap. */
);


struct JUNO_DS_HEAP_API_TAG JUNO_MODULE_API_DERIVE(JUNO_DS_ARRAY_API_T,
    /// Compare two values to perform the heap operation
    JUNO_DS_HEAP_COMPARE_RESULT_T (*Compare)(JUNO_DS_HEAP_ROOT_T *ptHeap, JUNO_POINTER_T tParent, JUNO_POINTER_T tChild);
    JUNO_STATUS_T (*Swap)(JUNO_DS_HEAP_ROOT_T *ptHeap, JUNO_POINTER_T tLeft, JUNO_POINTER_T tRight);
    JUNO_STATUS_T (*Insert)(JUNO_DS_HEAP_ROOT_T *ptHeap, JUNO_POINTER_T tValue);
    JUNO_STATUS_T (*Heapify)(JUNO_DS_HEAP_ROOT_T *ptHeap);
    JUNO_STATUS_T (*Pop)(JUNO_DS_HEAP_ROOT_T *ptHeap, JUNO_POINTER_T tReturn);
);

#define JunoDs_HeapApiInit(SetAt, GetAt, RemoveAt, Compare, Swap) \
{\
    {SetAt, GetAt, RemoveAt}, \
    Compare, \
    Swap, \
    JunoDs_Heap_Insert, \
    JunoDs_Heap_Heapify, \
    JunoDs_Heap_Pop, \
}

/**
 * @brief Bubble-up the last inserted element to restore the heap property.
 *
 * Typical usage:
 *  - After JunoDs_Heap_Insert(...), write your element to the returned index,
 *    then call Update to reposition it upward as needed.
 *
 * Returns:
 *  - JUNO_STATUS_SUCCESS on success.
 *  - JUNO_STATUS_ERR if zLength == 0, if Compare fails, if Swap fails, or if
 *    the computed parent index would exceed zCapacity. See tests/test_heap.c.
 */
JUNO_STATUS_T JunoDs_Heap_Update(JUNO_DS_HEAP_ROOT_T *ptHeap);
JUNO_STATUS_T JunoDs_Heap_Insert(JUNO_DS_HEAP_ROOT_T *ptHeap, JUNO_POINTER_T tValue);
JUNO_STATUS_T JunoDs_Heap_Heapify(JUNO_DS_HEAP_ROOT_T *ptHeap);
JUNO_STATUS_T JunoDs_Heap_Pop(JUNO_DS_HEAP_ROOT_T *ptHeap, JUNO_POINTER_T tReturn);

/**
 * @brief Sift down from a starting index to restore the heap property.
 *
 * Typical usage:
 *  - Used internally by Delete and Heapify. You can also call it directly if
 *    you overwrite the root or another node and need to restore ordering.
 *
 * Returns:
 *  - JUNO_STATUS_SUCCESS on success.
 *  - JUNO_STATUS_ERR if zLength == 0, if child indices exceed capacity, or if
 *    Compare/Swap report an error.
 */
JUNO_STATUS_T JunoDs_Heap_SiftDown(JUNO_DS_HEAP_ROOT_T *ptHeap, size_t iStart);

/**
 * @brief Verify that the heap root has been initialized properly.
 * @return JUNO_STATUS_SUCCESS if ptHeap != NULL, ptHeap->ptApi != NULL, and zCapacity > 0;
 *         JUNO_STATUS_NULLPTR_ERROR otherwise.
 */
static inline JUNO_STATUS_T JunoDs_Heap_Verify(JUNO_DS_HEAP_ROOT_T *ptHeap)
{
    JUNO_ASSERT_EXISTS(
        ptHeap &&
        ptHeap->ptApi &&
        ptHeap->ptApi->Compare &&
        ptHeap->ptApi->Swap &&
        ptHeap->ptApi->Insert &&
        ptHeap->ptApi->Heapify &&
        ptHeap->ptApi->Pop
    );
    return JunoDs_ArrayVerify(&ptHeap->tRoot);
}

/**
 * @brief Initialize a heap root with the given API and capacity.
 *
 * This does not allocate storage or touch your element array. It simply sets the
 * API pointer, length, and capacity.
 *
 * @param ptHeap Pointer to the heap root (first member of your derived type).
 * @param ptApi  Pointer to your API implementation (Compare/Swap/Reset).
 * @param zCapacity Maximum number of elements this heap may contain.
 * @return JUNO_STATUS_SUCCESS on success; JUNO_STATUS_NULLPTR_ERROR otherwise.
 */
static inline JUNO_STATUS_T JunoDs_Heap_Init(JUNO_DS_HEAP_ROOT_T *ptHeap, const JUNO_DS_HEAP_API_T *ptApi, size_t zCapacity, JUNO_FAILURE_HANDLER_T pfcnFailureHdlr, JUNO_USER_DATA_T *pvUserData)
{
    JUNO_ASSERT_EXISTS(ptHeap);
    ptHeap->ptApi = ptApi;
    ptHeap->zLength = 0;
    JUNO_STATUS_T tStatus = JunoDs_ArrayInit(&ptHeap->tRoot, &ptApi->tRoot, zCapacity, pfcnFailureHdlr, pvUserData);
    JUNO_ASSERT_SUCCESS(tStatus, return tStatus;)
    return JunoDs_Heap_Verify(ptHeap);
}
#ifdef __cplusplus
}
#endif
#endif // JUNO_DS_API_H
