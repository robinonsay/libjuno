/*
    MIT License

    Copyright (c) 2025 Robin A. Onsay

    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.
*/

/**
    This API has been generated by LibJuno:
    https://www.robinonsay.com/libjuno/
*/

/**
 * @file heap_api.h
 * @brief Heap data structure API built on the array abstraction.
 * @defgroup juno_ds_heap Heap API
 * @details
 *  A binary heap interface parameterized by element comparison and swap
 *  operations. Backed by a JUNO_DS_ARRAY_ROOT_T for storage. Provides
 *  Insert/Heapify/Pop operations and helpers like Update (bubble up) and
 *  SiftDown.
 */
#ifndef JUNO_DS_API_H
#define JUNO_DS_API_H
#include "juno/ds/array_api.h"
#include "juno/macros.h"
#include "juno/memory/pointer_api.h"
#include "juno/status.h"
#include "juno/module.h"
#include <stdbool.h>
#include <stddef.h>
#ifdef __cplusplus
extern "C"
{
#endif

typedef struct JUNO_DS_HEAP_ROOT_TAG JUNO_DS_HEAP_ROOT_T;   /**< Opaque root that stores heap metadata and API pointer. */
typedef struct JUNO_DS_HEAP_API_TAG  JUNO_DS_HEAP_API_T;    /**< API vtable you implement for your storage and element type. */
typedef struct JUNO_DS_HEAP_POINTER_API_TAG JUNO_DS_HEAP_POINTER_API_T;

/**
 * @brief Result type carrying an index on success.
 * tStatus conveys success/error; tOk holds the index.
 */
JUNO_MODULE_RESULT(JUNO_DS_HEAP_INDEX_RESULT_T, size_t);

/**
 * @brief Option type for an index. bIsSome indicates presence; tSome is the index.
 */
JUNO_MODULE_OPTION(JUNO_DS_HEAP_INDEX_OPTION_T, size_t);

/**
 * @brief Result that wraps an optional index.
 */
JUNO_MODULE_RESULT(JUNO_DS_HEAP_INDEX_OPTION_RESULT_T, JUNO_DS_HEAP_INDEX_OPTION_T);

/**
 * @brief Result of a comparison: tOk=true means the heap property holds
 * between the given parent and child indices; false means it does not.
 */
JUNO_MODULE_RESULT(JUNO_DS_HEAP_COMPARE_RESULT_T, bool);


struct JUNO_DS_HEAP_ROOT_TAG JUNO_MODULE_ROOT(JUNO_DS_HEAP_API_T,
    const JUNO_DS_HEAP_POINTER_API_T *ptHeapPointerApi;
    JUNO_DS_ARRAY_ROOT_T *ptHeapArray;
    size_t zLength;     /**< Current number of elements in the heap. */
);

/** @brief Element-level operations required by the heap. */
struct JUNO_DS_HEAP_POINTER_API_TAG
{
    /// @brief Compare two values to determine ordering.
    JUNO_DS_HEAP_COMPARE_RESULT_T (*Compare)(JUNO_DS_HEAP_ROOT_T *ptHeap, JUNO_POINTER_T tParent, JUNO_POINTER_T tChild);
    /// @brief Swap two values in the underlying storage.
    JUNO_STATUS_T (*Swap)(JUNO_DS_HEAP_ROOT_T *ptHeap, JUNO_POINTER_T tLeft, JUNO_POINTER_T tRight);
};

struct JUNO_DS_HEAP_API_TAG
{
    /// @brief Insert a new element into the heap.
    JUNO_STATUS_T (*Insert)(JUNO_DS_HEAP_ROOT_T *ptHeap, JUNO_POINTER_T tValue);
    /// @brief Transform the underlying array into a heap in-place.
    JUNO_STATUS_T (*Heapify)(JUNO_DS_HEAP_ROOT_T *ptHeap);
    /// @brief Pop the root element (extreme) into tReturn.
    JUNO_STATUS_T (*Pop)(JUNO_DS_HEAP_ROOT_T *ptHeap, JUNO_POINTER_T tReturn);
};

/**
 * @brief Bubble-up the last inserted element to restore the heap property.
 *
 * Typical usage:
 *  - After JunoDs_Heap_Insert(...), write your element to the returned index,
 *    then call Update to reposition it upward as needed.
 *
 * Returns:
 *  - JUNO_STATUS_SUCCESS on success.
 *  - JUNO_STATUS_ERR if zLength == 0, if Compare fails, if Swap fails, or if
 *    the computed parent index would exceed zCapacity. See tests/test_heap.c.
 */
JUNO_STATUS_T JunoDs_Heap_Update(JUNO_DS_HEAP_ROOT_T *ptHeap);
JUNO_STATUS_T JunoDs_Heap_Insert(JUNO_DS_HEAP_ROOT_T *ptHeap, JUNO_POINTER_T tValue);
JUNO_STATUS_T JunoDs_Heap_Heapify(JUNO_DS_HEAP_ROOT_T *ptHeap);
JUNO_STATUS_T JunoDs_Heap_Pop(JUNO_DS_HEAP_ROOT_T *ptHeap, JUNO_POINTER_T tReturn);
JUNO_STATUS_T JunoDs_Heap_Init(JUNO_DS_HEAP_ROOT_T *ptHeap, const JUNO_DS_HEAP_POINTER_API_T *ptHeapPointerApi, JUNO_DS_ARRAY_ROOT_T *ptHeapArray, JUNO_FAILURE_HANDLER_T pfcnFailureHdlr, JUNO_USER_DATA_T *pvUserData);

/**
 * @brief Sift down from a starting index to restore the heap property.
 *
 * Typical usage:
 *  - Used internally by Delete and Heapify. You can also call it directly if
 *    you overwrite the root or another node and need to restore ordering.
 *
 * Returns:
 *  - JUNO_STATUS_SUCCESS on success.
 *  - JUNO_STATUS_ERR if zLength == 0, if child indices exceed capacity, or if
 *    Compare/Swap report an error.
 */
JUNO_STATUS_T JunoDs_Heap_SiftDown(JUNO_DS_HEAP_ROOT_T *ptHeap, size_t iStart);

/**
 * @brief Verify that the heap root has been initialized properly.
 * @return JUNO_STATUS_SUCCESS if ptHeap != NULL, ptHeap->ptApi != NULL, and zCapacity > 0;
 *         JUNO_STATUS_NULLPTR_ERROR otherwise.
 */
/**
 * @brief Verify heap configuration and dependent APIs.
 */
static inline JUNO_STATUS_T JunoDs_Heap_Verify(JUNO_DS_HEAP_ROOT_T *ptHeap)
{
    JUNO_ASSERT_EXISTS(
        ptHeap &&
        ptHeap->ptHeapArray &&
        ptHeap->ptHeapPointerApi &&
        ptHeap->ptHeapPointerApi->Compare &&
        ptHeap->ptHeapPointerApi->Swap &&
        ptHeap->ptApi &&
        ptHeap->ptApi->Insert &&
        ptHeap->ptApi->Heapify &&
        ptHeap->ptApi->Pop
    );
    return JunoDs_ArrayVerify(ptHeap->ptHeapArray);
}
#ifdef __cplusplus
}
#endif
#endif // JUNO_DS_API_H
