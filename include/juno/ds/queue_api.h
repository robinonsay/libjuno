/*
    MIT License

    Copyright (c) 2025 Robin A. Onsay

    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.
*/

/**
    This API has been generated by LibJuno:
    https://www.robinonsay.com/libjuno/
*/

/**
 * @file queue_api.h
 * @brief Fixed-capacity FIFO queue built on the Array API.
 * @defgroup juno_ds_queue Queue API
 * @details
 *  A lightweight, fixed-capacity FIFO queue that stores elements in a
 *  circular buffer backed by a Juno Array instance. The queue uses
 *  JUNO_POINTER_T to copy elements into the backing array and to return them.
 *
 *  Characteristics:
 *  - Deterministic O(1) enqueue/dequeue/peek.
 *  - Capacity defined by the backing array; no dynamic allocation.
 *  - Non-thread-safe by default; guard externally if needed.
 *
 *  Invariants:
 *  - 0 <= zLength <= ptQueueArray->zCapacity
 *  - iStartIndex < ptQueueArray->zCapacity (when capacity > 0)
 *  - Backing array API must be valid (see JunoDs_ArrayVerify).
 *
 *  Error behavior (per implementation):
 *  - Enqueue on full queue: returns JUNO_STATUS_INVALID_SIZE_ERROR.
 *  - Dequeue on empty queue: returns JUNO_STATUS_ERR.
 *  - Peek on empty queue: returns JUNO_STATUS_INVALID_SIZE_ERROR.
 *
 *  Element ownership:
 *  - Elements are copied into/out of the array via the pointer API (Copy),
 *    so tItem/tReturn must describe a valid storage location and size.
 */
#ifndef JUNO_DS_QUEUE_API_H
#define JUNO_DS_QUEUE_API_H
#include "juno/ds/array_api.h"
#include "juno/macros.h"
#include "juno/memory/pointer_api.h"
#include "juno/status.h"
#include "juno/module.h"
#include <stddef.h>
#ifdef __cplusplus
extern "C"
{
#endif

/// The queue root module
typedef struct JUNO_DS_QUEUE_ROOT_TAG JUNO_DS_QUEUE_ROOT_T;
typedef struct JUNO_DS_QUEUE_API_TAG  JUNO_DS_QUEUE_API_T;

/// The queue root module instance.
/**
 * @brief Queue root instance and state.
 * @ingroup juno_ds_queue
 */
struct JUNO_DS_QUEUE_ROOT_TAG JUNO_MODULE_ROOT(JUNO_DS_QUEUE_API_T,
    JUNO_DS_ARRAY_ROOT_T *ptQueueArray; /**< Backing array defining capacity and element ops. */
    size_t iStartIndex;                 /**< Index of the logical front element. */
    size_t zLength;                     /**< Current number of elements in the queue. */
);

/**
 * @brief Queue API vtable.
 * @ingroup juno_ds_queue
 */
struct JUNO_DS_QUEUE_API_TAG
{
    /// @brief Enqueue an item to the back of the queue.
    /// @param ptQueue Queue instance.
    /// @param tItem Pointer trait describing the item to copy into the queue.
    /// @return JUNO_STATUS_SUCCESS on success; JUNO_STATUS_INVALID_SIZE_ERROR if full; or pointer/array errors.
    JUNO_STATUS_T (*Enqueue)(JUNO_DS_QUEUE_ROOT_T *ptQueue, JUNO_POINTER_T tItem);
    /// @brief Dequeue the item at the front of the queue.
    /// @param ptQueue Queue instance.
    /// @param tReturn Pointer trait receiving the dequeued item (copied out).
    /// @return JUNO_STATUS_SUCCESS on success; JUNO_STATUS_ERR if empty; or pointer/array errors.
    JUNO_STATUS_T (*Dequeue)(JUNO_DS_QUEUE_ROOT_T *ptQueue, JUNO_POINTER_T tReturn);
    /// @brief Peek at the item at the front without removing it.
    /// @param ptQueue Queue instance.
    /// @return Result with pointer descriptor to the front element; JUNO_STATUS_INVALID_SIZE_ERROR if empty.
    JUNO_RESULT_POINTER_T (*Peek)(JUNO_DS_QUEUE_ROOT_T *ptQueue);
};

/**
 * @brief Verify that the queue API provides all required functions.
 */
static inline JUNO_STATUS_T JunoDs_QueueApiVerify(const JUNO_DS_QUEUE_API_T *ptQueueApi)
{
     JUNO_ASSERT_EXISTS(
        ptQueueApi &&
        ptQueueApi->Enqueue &&
        ptQueueApi->Dequeue &&
        ptQueueApi->Peek
    );
    return JUNO_STATUS_SUCCESS;   
}

/// @brief Verify a queue instance and its API table.
static inline JUNO_STATUS_T JunoDs_QueueVerify(const JUNO_DS_QUEUE_ROOT_T *ptQueue)
{
    JUNO_ASSERT_EXISTS(ptQueue);
    JUNO_STATUS_T tStatus = JunoDs_ArrayVerify(ptQueue->ptQueueArray);
    JUNO_ASSERT_SUCCESS(tStatus, return tStatus);
    return JunoDs_QueueApiVerify(ptQueue->ptApi);
}

/// @brief Enqueue an item to the back of the queue (O(1)).
JUNO_STATUS_T JunoDs_QueuePush(JUNO_DS_QUEUE_ROOT_T *ptQueue, JUNO_POINTER_T tItem);
/// @brief Dequeue the item at the front of the queue into tReturn (O(1)).
JUNO_STATUS_T JunoDs_QueuePop(JUNO_DS_QUEUE_ROOT_T *ptQueue, JUNO_POINTER_T tReturn);
/// @brief Peek at the item at the front without removing it (O(1)).
JUNO_RESULT_POINTER_T JunoDs_QueuePeek(JUNO_DS_QUEUE_ROOT_T *ptQueue);

/// @brief Initialize a queue over a backing array with a given capacity.
/// @param ptQueue Queue to initialize (output).
/// @param ptQueueArray Backing array used for storage; defines capacity and element size.
/// @param pfcnFailureHdlr Failure callback for assertions in this module.
/// @param pvFailureUserData Opaque user data for the failure handler.
/// @return JUNO_STATUS_SUCCESS on success; error if array verification fails.
JUNO_STATUS_T JunoDs_QueueInit(JUNO_DS_QUEUE_ROOT_T *ptQueue, JUNO_DS_ARRAY_ROOT_T *ptQueueArray, JUNO_FAILURE_HANDLER_T pfcnFailureHdlr, JUNO_USER_DATA_T *pvFailureUserData);

#ifdef __cplusplus
}
#endif
#endif // JUNO_DS_QUEUE_API_H
