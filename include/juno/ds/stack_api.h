/*
    MIT License

    Copyright (c) 2025 Robin A. Onsay

    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.
*/

/**
    This API has been generated by LibJuno:
    https://www.robinonsay.com/libjuno/
*/

/**
 * @file stack_api.h
 * @brief Fixed-capacity LIFO stack built on the Array API.
 * @defgroup juno_ds_stack Stack API
 * @details
 *  A deterministic, fixed-capacity stack (LIFO) backed by a Juno Array.
 *  Elements are copied using JUNO_POINTER_T when pushing and popping.
 *  Capacity is defined by the backing array. Non-thread-safe by default.
 *
 *  Characteristics:
 *  - O(1) push/pop/peek
 *  - No dynamic allocation; capacity determined by backing array
 *
 *  Invariants:
 *  - 0 <= zLength <= ptStackArray->zCapacity
 *  - Backing array API must be valid (see JunoDs_ArrayVerify)
 *
 *  Error behavior (per implementation):
 *  - Push on full stack: returns JUNO_STATUS_INVALID_SIZE_ERROR
 *  - Pop on empty stack: returns JUNO_STATUS_INVALID_SIZE_ERROR
 *  - Peek on empty stack: returns JUNO_STATUS_INVALID_SIZE_ERROR
 *
 *  Element ownership:
 *  - Elements are copied into/out of the array via the pointer API (Copy),
 *    so tItem/tReturn must describe a valid storage location and size.
 */
#ifndef JUNO_DS_STACK_API_H
#define JUNO_DS_STACK_API_H
#include "juno/ds/array_api.h"
#include "juno/macros.h"
#include "juno/status.h"
#include "juno/module.h"
#ifdef __cplusplus
extern "C"
{
#endif

/// The stack root module
typedef struct JUNO_DS_STACK_ROOT_TAG JUNO_DS_STACK_ROOT_T;
typedef struct JUNO_DS_STACK_API_TAG JUNO_DS_STACK_API_T;

/**
 * @brief Stack root instance and state.
 * @ingroup juno_ds_stack
 */
struct JUNO_DS_STACK_ROOT_TAG JUNO_MODULE_ROOT(JUNO_DS_STACK_API_T,
    JUNO_DS_ARRAY_ROOT_T *ptStackArray; /**< Backing array defining capacity and element ops. */
    size_t zLength;                     /**< Current number of elements in the stack. */
);

struct JUNO_DS_STACK_API_TAG
{
    /// @brief Push an item onto the top of the stack (O(1)).
    /// @param ptStack Stack instance.
    /// @param tItem Pointer trait describing the item to copy into the stack.
    /// @return JUNO_STATUS_SUCCESS on success; JUNO_STATUS_INVALID_SIZE_ERROR if full; or pointer/array errors.
    JUNO_STATUS_T (*Push)(JUNO_DS_STACK_ROOT_T *ptStack, JUNO_POINTER_T tItem);
    /// @brief Pop the top item into tReturn (O(1)).
    /// @param ptStack Stack instance.
    /// @param tReturn Pointer trait receiving the popped item (copied out).
    /// @return JUNO_STATUS_SUCCESS on success; JUNO_STATUS_INVALID_SIZE_ERROR if empty; or pointer/array errors.
    JUNO_STATUS_T (*Pop)(JUNO_DS_STACK_ROOT_T *ptStack, JUNO_POINTER_T tReturn);
    /// @brief Peek at the top item without removing it (O(1)).
    /// @param ptStack Stack instance.
    /// @return Result with pointer descriptor to the top element; JUNO_STATUS_INVALID_SIZE_ERROR if empty.
    JUNO_RESULT_POINTER_T (*Peek)(JUNO_DS_STACK_ROOT_T *ptStack);
};

static inline JUNO_STATUS_T JunoDs_StackVerify(const JUNO_DS_STACK_ROOT_T *ptStack)
{
    JUNO_ASSERT_EXISTS(ptStack && ptStack->ptStackArray);
    JUNO_ASSERT_EXISTS(
        ptStack->ptApi &&
        ptStack->ptApi->Push &&
        ptStack->ptApi->Pop &&
        ptStack->ptApi->Peek
    );
    return JunoDs_ArrayVerify(ptStack->ptStackArray);
}

/// @brief Initialize a stack over a backing array with a given capacity.
/// @param ptStack Stack to initialize (output).
/// @param ptStackArray Backing array used for storage; defines capacity and element size.
/// @param pfcnFailureHdlr Failure callback for assertions in this module.
/// @param pvFailureUserData Opaque user data for the failure handler.
/// @return JUNO_STATUS_SUCCESS on success; error if array verification fails.
JUNO_STATUS_T JunoDs_StackInit(JUNO_DS_STACK_ROOT_T *ptStack, JUNO_DS_ARRAY_ROOT_T *ptStackArray, JUNO_FAILURE_HANDLER_T pfcnFailureHdlr, JUNO_USER_DATA_T *pvFailureUserData);

/// @brief Push an item onto the top of the stack (O(1)).
JUNO_STATUS_T JunoDs_StackPush(JUNO_DS_STACK_ROOT_T *ptStack, JUNO_POINTER_T tItem);
/// @brief Pop the top item into tReturn (O(1)).
JUNO_STATUS_T JunoDs_StackPop(JUNO_DS_STACK_ROOT_T *ptStack, JUNO_POINTER_T tReturn);
/// @brief Peek at the top item without removing it (O(1)).
JUNO_RESULT_POINTER_T JunoDs_StackPeek(JUNO_DS_STACK_ROOT_T *ptStack);



#ifdef __cplusplus
}
#endif
#endif // JUNO_DS_STACK_API_H
