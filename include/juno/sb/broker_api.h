/*
    MIT License

    Copyright (c) 2025 Robin A. Onsay

    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.
*/

/**
    This API has been generated by LibJuno:
    https://www.robinonsay.com/libjuno/
*/

/**
 * @file broker_api.h
 * @brief Software Bus (SB) broker for single-threaded message fan-out.
 * @defgroup juno_sb Software Bus Broker
 * @details
 *  The broker distributes messages to registered subscribers (pipes) within
 *  a single thread. It is intentionally not thread-safe to encourage explicit
 *  IPC design when multiple threads are involved (e.g., queues, sockets).
 *
 *  Messages are enqueued to subscriber pipes implemented as queues. The broker
 *  deals in JUNO_POINTER_T message handles; ownership and copy semantics follow
 *  the pointer trait provided by the application.
 */
#ifndef JUNO_SB_API_H
#define JUNO_SB_API_H
#include "juno/ds/array_api.h"
#include "juno/macros.h"
#include "juno/memory/pointer_api.h"
#include "juno/status.h"
#include "juno/module.h"
#include "juno/ds/queue_api.h"
#include <stddef.h>
#include <stdint.h>
#ifdef __cplusplus
extern "C"
{
#endif

typedef struct JUNO_SB_BROKER_ROOT_TAG JUNO_SB_BROKER_ROOT_T;
typedef struct JUNO_SB_BROKER_API_TAG JUNO_SB_BROKER_API_T;
typedef struct JUNO_SB_PIPE_TAG JUNO_SB_PIPE_T;
typedef uint32_t JUNO_SB_MID_T;

/// A subscriber pipe that carries messages for a specific MID.
struct JUNO_SB_PIPE_TAG JUNO_MODULE_DERIVE(JUNO_DS_QUEUE_ROOT_T,
    /// The pipe Id (Message ID / topic).
    JUNO_SB_MID_T iMsgId;
);

/// Broker root containing the registry of subscriber pipes.
struct JUNO_SB_BROKER_ROOT_TAG JUNO_MODULE_ROOT(JUNO_SB_BROKER_API_T,
    /// The pipe registry (array of pointers to pipes).
    JUNO_SB_PIPE_T **ptPipeRegistry;
    /// The current length of the pipe registry.
    size_t zRegistryLength;
    /// Maximum number of pipes that can be registered.
    size_t zRegistryCapacity;
);

struct JUNO_SB_BROKER_API_TAG
{
    /// @brief Publish a message to all subscribers of tMid.
    /// @param ptBroker Broker instance.
    /// @param tMid Message ID / topic.
    /// @param tMsg Message handle (copied/enqueued per pointer trait).
    JUNO_STATUS_T (*Publish)(JUNO_SB_BROKER_ROOT_T *ptBroker, JUNO_SB_MID_T tMid, JUNO_POINTER_T tMsg);
    /// @brief Register a subscriber pipe with the broker.
    JUNO_STATUS_T (*RegisterSubscriber)(JUNO_SB_BROKER_ROOT_T *ptBroker, JUNO_SB_PIPE_T *ptPipe);
};

/// @brief Verify a broker API table has required functions.
static inline JUNO_STATUS_T JunoSb_BrokerApiVerify(const JUNO_SB_BROKER_API_T *ptBrokerApi)
{
    JUNO_ASSERT_EXISTS(
        ptBrokerApi &&
        ptBrokerApi->Publish &&
        ptBrokerApi->RegisterSubscriber
    );
    return JUNO_STATUS_SUCCESS;
}

/// @brief Verify a broker instance and basic registry invariants.
static inline JUNO_STATUS_T JunoSb_BrokerVerify(const JUNO_SB_BROKER_ROOT_T *ptBroker)
{
    JUNO_STATUS_T tStatus = JUNO_STATUS_SUCCESS;
    JUNO_ASSERT_EXISTS(ptBroker);
    tStatus = JunoSb_BrokerApiVerify(ptBroker->ptApi);
    JUNO_ASSERT_SUCCESS(tStatus, return tStatus);
    JUNO_ASSERT_EXISTS(ptBroker->ptPipeRegistry && ptBroker->zRegistryCapacity);
    return tStatus;
}

/// @brief Verify a pipe instance.
static inline JUNO_STATUS_T JunoSb_PipeVerify(const JUNO_SB_PIPE_T *ptPipe)
{
    JUNO_ASSERT_EXISTS(ptPipe);
    JUNO_STATUS_T tStatus = JunoDs_QueueVerify(&ptPipe->tRoot);
    JUNO_ASSERT_SUCCESS(tStatus, return tStatus);
    return tStatus;
}

/// @brief Initialize a broker with a pipe registry storage array.
JUNO_STATUS_T JunoSb_BrokerInit(JUNO_SB_BROKER_ROOT_T *ptBroker, JUNO_SB_PIPE_T **ptPipeRegistry, size_t iRegistryCapacity, JUNO_FAILURE_HANDLER_T pfcnFailureHdlr, JUNO_USER_DATA_T *pvFailureUserData);

/// @brief Initialize a pipe for a specific MID backed by a queue over ptArray.
static inline JUNO_STATUS_T JunoSb_PipeInit(JUNO_SB_PIPE_T *ptPipe, JUNO_SB_MID_T iMid, JUNO_DS_ARRAY_ROOT_T *ptArray, JUNO_FAILURE_HANDLER_T pfcnFailureHandler, JUNO_USER_DATA_T *pvUserData)
{
    JUNO_ASSERT_EXISTS(ptPipe);
    ptPipe->iMsgId = iMid;
    return JunoDs_QueueInit(&ptPipe->tRoot, ptArray, pfcnFailureHandler, pvUserData);
}

#ifdef __cplusplus
}
#endif
#endif // JUNO_SB_API_H
